---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


This is saved code which probably will not be used.
# Label Switching

Since we know the data in this example, we can use the very simple constraint that $\rho_{8} < \rho_{12}$ in clusters 1 and 2. Note that we can only use this approach because we created the data, and know that potatoes 8 and 12 are at the extremes of the rankings in each cluster. We also try the ECR algorithm, developed in @papastamoulis2010. Both methods are implemented in the R package `label.switching` (@papastamoulis2016).

We first define a function for finding the pivot allocation used by ECR:

```{r, message=FALSE}
library(dplyr)
library(tidyr)

find_pivot_allocation <- function(model_fit){
  # Find the MAP estimate of cluster allocation
  # We use functions from the dplyr and tidyr packages
  zpivot <- model_fit$cluster_indicator %>% 
    as_tibble() %>% 
    group_by_all() %>% 
    count() %>% 
    ungroup() %>% 
    filter(n == max(n)) %>% 
    select(-n) %>% 
    gather() %>% 
    pull()  
  
  zpivot <- matrix(zpivot, nrow = 1)
  
  return(zpivot)
}

```


```{r, message=FALSE}
library(label.switching)

burnin <- floor(nmc / 2)
iteration_sequence <- seq(from = burnin + 1, to = model_fit1$nmc, by = 1)  

switch_labels <- function(model_fit, iteration_sequence){
  
  zpivot <- find_pivot_allocation(model_fit)
  mcmc_pars <- array(dim = c(length(iteration_sequence), model_fit$n_clusters, 2))
  
  # Potatoes 8 and 12, cluster 1
  mcmc_pars[, 1,] <- t(model_fit$rho[c(8, 12), iteration_sequence, 1])
  # Potatoes 8 and 12, cluster 2
  mcmc_pars[, 2,] <- t(model_fit$rho[c(8, 12), iteration_sequence, 2])
  
  # Cluster allocations
  latent_allocations <- matrix(nrow = length(iteration_sequence), ncol = model_fit$n_assessors)
  latent_allocations[] <- as.integer(model_fit$cluster_indicator[iteration_sequence, ])
  
  ls <- label.switching(
    method = c("AIC", "ECR"),
    zpivot = zpivot,
    z = latent_allocations,
    K = 2,
    mcmc = mcmc_pars
  )

  return(ls)

}

ls1 <- switch_labels(model_fit1, iteration_sequence)
ls2 <- switch_labels(model_fit2, iteration_sequence)

```

Here is a little function for permuting $\rho$ based on the `ls` object returned from the `label.switching` method.

```{r}
permute_rho <- function(perm, model_fit, iteration_sequence){
  # Logical vector indicating wether to permute or not.
  # ONLY VALID FOR THE K=2 CLUSTER CASE!!
  permute <- (perm[, 1] == 2) & (perm[, 2] == 1)  
  
  # No need to do anything
  if(all(permute) || all(!permute)){
    message("No permutation needed")
    return(model_fit$rho)
  }
  
  # Do the least number of permutations necessary
  if(mean(permute) > 0.5) permute <- !permute
  
  message(paste("Permuting", sum(permute), "rows,"))
  rho_perm <- model_fit$rho
  
  for(i in seq_along(iteration_sequence)){
    if(permute[i]){
      rho_perm[ , iteration_sequence[[i]], 1:2] <- rho_perm[, iteration_sequence[[i]], 2:1]
    }
  }
  
  return(rho_perm)
}


```

We permute the labels, and store them into new model objects.
```{r}
model_fit_aic1 <- model_fit1
model_fit_aic1$rho <- permute_rho(ls1$permutations$AIC, model_fit1, iteration_sequence)

model_fit_ecr1 <- model_fit1
model_fit_ecr1$rho <- permute_rho(ls1$permutations$ECR, model_fit1, iteration_sequence)

```

```{r}
model_fit_aic2 <- model_fit2
model_fit_aic2$rho <- permute_rho(ls2$permutations$AIC, model_fit2, iteration_sequence)

model_fit_ecr2 <- model_fit2
model_fit_ecr2$rho <- permute_rho(ls2$permutations$ECR, model_fit2, iteration_sequence)
```


We can compare before and after label switching. Note that the label switching algorihtm comes into play only after the burnin period.

```{r, fig.width=6}
# Original model object
assess_convergence(model_fit1, type = "rho", items = c(8, 12))
# Constraint based label permutation
assess_convergence(model_fit_aic1, type = "rho", items = c(8, 12))
# Label permutation with ECR algorithm
assess_convergence(model_fit_ecr1, type = "rho", items = c(8, 12))
```

```{r, fig.width=6}
# Original model object
assess_convergence(model_fit2, type = "rho", items = c(8, 12))
# Constraint based label permutation
assess_convergence(model_fit_aic2, type = "rho", items = c(8, 12))
# Label permutation with ECR algorithm
assess_convergence(model_fit_ecr2, type = "rho", items = c(8, 12))
```

We go on working with the object `model_fit2`. Label switching did not seem to be a big issue here.

```{r}
model_fit <- model_fit2
rm(model_fit1, model_fit_aic1, model_fit_ecr1, model_fit2, model_fit_aic2, model_fit_ecr2)
```

