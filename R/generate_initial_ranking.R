#' Title
#'
#' @param tc A dataframe with the transitive closure of pairwise comparisons. If
#'   it has class \code{BayesMallowsTC}, generated by
#'   \code{\link{generate_transitive_closure}}, this will be used. Otherwise,
#'   \code{\link{generate_transitive_closure}} will be called on this dataframe.
#' @param num_items The total number of items. If not provided, it is assumed to
#'   equal to \code{max(tc[, c("bottom_item", "top_item")])}.
#' @export
generate_initial_ranking <- function(tc,
                                     num_items = max(tc[, c("bottom_item", "top_item")])){

  if(!("BayesMallowsTC" %in% class(tc))){
    P <- generate_transitive_closure(tc)
  }

  create_ranks <- function(mat, num_items){
    g <- igraph::graph_from_edgelist(mat)
    g <- as.integer(igraph::topological.sort(g))

    # Add unranked elements at the end
    all_items <- seq(from = 1, to = num_items, by = 1)
    g <- c(g, setdiff(all_items, g))

    # Convert from ordering to ranking
    r <- create_ranking(rev(g))
    mat <- matrix(r, nrow = 1)

    return(mat)
  }
  # Find
  tc <- dplyr::group_by(tc, .data$assessor)
  tc <- dplyr::do(tc, dplyr::as_tibble(
      x = create_ranks(
        as.matrix(.data[, c("bottom_item", "top_item"), drop = FALSE]),
        num_items = !!num_items)
      ))

  mat <- as.matrix(tc[, -1, drop = FALSE])
  rownames(mat) <- tc[["assessor"]]
  colnames(mat) <- seq(from = 1, to = num_items, by = 1)
  return(mat)
}

