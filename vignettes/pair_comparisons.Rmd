---
title: "Pairwise Comparisons"
author: "Oystein Sorensen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(33232)
```

## Working with Pairwise Comparisons
Pairwise comparisons are described in Section 4.2 of @vitelli2018. Let us start by considering a toy example with two assessors and five items. Assessor 1 has stated a set of preferences
$$ \mathcal{B}_{1} = \left\{A_{1} \prec A_{2}, A_{2} \prec A_{5}, A_{4} \prec A_{5} \right\} $$
and assessor 2 has the set of preferences
$$ \mathcal{B}_{2} = \left\{ A_{1} \prec A_{2}, A_{2} \prec A_{3}, A_{3} \prec A_{4} \right\}. $$

### Data Model
Each time an assessor is asked to compare two objects, a measurement is made. Therefore, in order to keep the data *tidy* (@wickham2014), we define a dataframe in which each row corresponds to a pairwise comparison. The columns (variables) are *the assessor*, *the bottom item*, and *the top item*. 

In the code snippet below, we defined such a dataframe:

```{r, message=FALSE, results='asis'}
library(BayesMallows)
library(dplyr)
pair_comp <- tribble(
  ~assessor, ~bottom_item, ~top_item,
  1, 1, 2,
  1, 2, 5,
  1, 4, 5,
  2, 1, 2,
  2, 2, 3,
  2, 3, 4
)

knitr::kable(pair_comp)
```

### Generating the Transitive Closure

Next, we need to find the transitive closure for the set of pairwise comparisons given by each user. `BayesMallows` comes with a function `generate_transitive_closure` to do just this.


```{r}
pair_comp_tc <- generate_transitive_closure(pair_comp)
```

As we can see, `pair_comp_tc` has an additional row containing the relation $A_{4} \prec A_{5}$ for assessor 1. For assessor 2, $$\text{tc}(\mathcal{B}_{2}) = \mathcal{B}_{2} \cup \left\{ A_{1} \prec A_{3}, A_{1} \prec A_{4}, A_{2} \prec A_{4}\right\},$$ so three new rows have been added.

```{r, echo=FALSE, results='asis'}
knitr::kable(pair_comp_tc)
```

The dataframe returned by `generate_transitive_closure` inherits from `tibble`, but has subclass `BayesMallowsTC`. The `compute_mallows` function uses this information to ensure that the object provided has been through the `generate_transitive_closure` function. If it has not, `compute_mallows` will do it for us, but this may lead to additional computing time when running several diagnostic runs and trying out different parameters, since the transitive closure will be recomputed each time.

```{r}
class(pair_comp_tc)
```


### Some Algorithmic Notes

In order to go on from here, we need to generate an initial ranking $R_{j}, ~j=1,\dots,N$ which is compliant with $\text{tc}(\mathcal{B}_{j})$. We must also provide, for each assessor $j$, a set of items that are constrained, $\mathcal{A}_{j}$ in the notation of the paper. Then we draw a random integer $u \in \{1, \dots, n\}$. 

If $u \in \mathcal{A}_{j}$ we find the elements in $\mathcal{A}_{j}$ which are ranked below $u$. Here is an example. I must write this function in `C++`.

```{r}
u <- 5 # Imagine this is the random number
j <- 1
pair_comp_tc %>% 
  filter(assessor == !!j, top_item == !!u) %>% 
  pull(bottom_item)
```
Having a rank vector $R_{j}$, the left-handed limit is now $l_{j} = \text{max}(R_{j1}, R_{j2}, R_{j4})$.

The right-handed limit is similarly:
```{r}
pair_comp_tc %>% 
  filter(assessor == !!j, bottom_item == !!u) %>% 
  pull(top_item)
```
Since this is the empty set in this particular case, $r_{j} = n+1$. We now draw a proposal uniformly from the set $\{l_{j}+1, \dots, r_{j} - 1\}$.

### Generating the Initial Ranking

We can also generate an initial ranking, consistent with the pairwise comparisons. Again, `compute_mallows` will do it for us, but we may save time by computing it once and for all before we starting running the algorithms.

```{r}
initial_ranking <- generate_initial_ranking(pair_comp_tc)
```

```{r, results='asis'}
knitr::kable(initial_ranking, row.names = TRUE)
```


## Mallows Model with Pairwise Preferences
Having generated the transitive closure of each assessor's pairwise preferences and the initial ranking, we can go on and use these as inputs to the Mallows model.

```{r}
model_fit <- compute_mallows(R = initial_ranking, P = pair_comp_tc)
```

The model object has `augpair` equal to `TRUE`, and contains the `aug_acceptance` statisics.

```{r}
str(model_fit)
```

We can study the acceptance rate of the proposed augmented ranks.
```{r, fig.width=6, fig.align='center'}
assess_convergence(model_fit, type = "augmentation")
```


# References
