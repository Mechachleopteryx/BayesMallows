---
title: "Incomplete Data"
author: "Oystein Sorensen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(232312)
```

This vignette assumes that you are familiar with the topics in the introductory vignette, so make sure you read that one first. We start by describing top-k rankings, and then go on with data missing at random.

## Top-k Rankings

Imagine that the assessors in the potato experiment were asked to rank only the top-five heaviest potatoes. We generate these data by retaining only ranks 5 or higher in `potato_visual`, setting the rest to `NA`.

```{r}
library(BayesMallows)
potato_top <- ifelse(potato_visual > 5, NA_real_, potato_visual)
```

Here is the resulting rank matrix:

```{r, echo=FALSE, results='asis'}
knitr::kable(potato_top, caption = "Example dataset potato_top.")
```

The `compute_mallows` function automatically recognizes the `NA` values as missing ranks, and augments the data. Let us try:

```{r}
model_fit <- compute_mallows(potato_top)
```

Looking at the returned object, we see that `any_missing` is `TRUE`, so `compute_mallows` has correctly detected that there are missing values.
```{r}
str(model_fit)
```

### Assessing Convergence

Saving the augmented ranks through every MCMC step would yield an array of size `nmc x n_items x n_assessors`, which quickly becomes prohibitively large. Thus, rather than saving this, we save an indicator array of size `nmc x n_assessors`, showing whether or not the proposed ranks were accepted for each assessor at each iteration. Even this matrix may become very large, so we should probably make it optional.

```{r, fig.width=6, fig.height=5, fig.align='center'}
assess_convergence(model_fit, type = "augmentation")
```

The `assess_convergence` tells us that the size of the rolling mean was set to 10. We can increase it to 100 and see if that changes the plots.

```{r, fig.width=6, fig.height=5, fig.align='center'}
assess_convergence(model_fit, type = "augmentation", k = 100)
```

We see that after some initial fluctuations, the augmentations settle close to zero, but not exactly at zero.

### Excluding Leftover Items
Same MAP, but not the same posterior distributions.

## Data Missing at Random

Point: If only one item has a missing rank, this can be filled in. This is not true for top-k rankings.

# References
